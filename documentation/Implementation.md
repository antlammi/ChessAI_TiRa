## Structure
### Model

The model package is in charge of providing the engine with the rules of chess and providing it with a list of moves from which to choose the best ones. 

Board.java initiates the two dimensional array of *Squares*, which is the logic for the game board with the correct *Pieces* in their starting positions. It also contains methods for cloning and printing boardstates.

Squares contain a Piece, and provide access to their location on the chess board. 

Piece.java is an interface, which is implemented all the different types of Pieces, which have different rules for movement but are all located on a Square, have an individual value assigned to them, and provide an array of *Moves*. 

Moves are the logic for a Move. All moves feature a starting Square (called current), a destination Square, and a Piece to move. When a Move is executed it also updates the Squares involved, and the Piece value for the Piece that was moved. Some Moves have special rules, that mean they function differently. The Move class also handles these.

The Player.java class is in charge of one player in a chess game. It contains information about where the that Player's Pieces are located, and what Pieces remain. It also maintains the Score for the player, which is used by the Engine classes to determine which move is best. It's primary function, however is to provide an array of legal Moves to the Engine.

The Game.java class handles an actual game of chess. This includes asking for Moves from Players and updating the Players statuses after each move. It also checks for mates after each move is made.

Below is a diagram showing roughly the relationships of the classes in the kufbot.model package. In actuality the Board class is only initially used to create a two dimensional array of Squares, which is then used by the classes in question. 
  
![Class Diagram](https://github.com/antlammi/ChessAI_TiRa/blob/master/documentation/Chess%20Engine%20Diagram.png)   
    
    
### Engine

The engine package contains the logic for the chess engine itself, or how the engine chooses what it considers the best one 
from a list of available moves. It contains the Engine.java interface, which is implemented by a few different classes, each of which is its own implementation of a chess engine. For now among these is the class enabling a human player to manually input moves.

### Connection

The connection package handles connecting the application to the XBoard app. It reads commands from XBoard, given as Strings in an input stream through anonymous pipes automatically generated by XBoard, and similarly outputs commands. Whenever a move is given from XBoard, it is converted to a Move class object by the method convertToMove. This is mostly really straightforward, with only a few special cases required for castling moves (as the engine has a different syntax for them). The only other XBoard commands implemented are "new", which signifies starting a new game with the black pieces (and to wait for a move command to be given), and "go" which tells the engine to start playing a new game with the white pieces.


### MinmaxAB
Briefly the core idea of the algorithm: The best moves for both players are evaluated until the maximum depth is reached or the game ends. Four values are maintained: maxScore, minScore, alpha and beta. Individual positions are evaluated by comparing the value of both players pieces (or in the case the game ends, a move's score is set to 1000000 (mate), or 0.0 (stalemate) as a special case)

Variable maxScore refers to the best score available for the player initiating the search. In this implementation it is received through the move class as an actual move needs to be provided to the game.   

Variable minScore refers to the best score available to the opposing player, again provided by the move itself.     

Variable alpha is the best score the player initiating the search is assured of based on moves already looked at.
Variable beta is the best score the opponent is assured of based on moves already looked at.    

Using alpha and beta some subtrees can be completely ignored, as a better move is guaranteed to exist.  

## Example
Below is a sequence diagram of how MinmaxAB generates a move for the engine. Note that it at every other depth the player, whose move is being considered changes. This is not made very clear by the diagram.
![Sequence Diagram](https://github.com/antlammi/ChessAI_TiRa/blob/master/documentation/Sequence%20Diagram%20MinmaxAB.png)

## Achieved performance 
### MinmaxAB
Currently the MinmaxAB implementation is actually decent. Some additional time is spent copying boardstates for moves (which strictly speaking is not necessary, but was rather difficult to get rid of without causing issues with the implementation of the model). Outside of getting rid of this this, the main way to improve performance for the algorithm itself would be actually building and sustaining a tree during the initial search. After this, the executed move would be turned into the root of the tree, and other subtrees would be disregarded. Then only the nodes at maximum depth would need to be searched, providing a significant improvement to performance. This was mostly not done due to time constraints with the project. As the Minmax algorithm logically already works like a tree, this would not be too difficult to implement.
 
### Model
The Model implementation could be improved a lot in terms of performance. Mainly the issues lie in Moves and Boardstates being redundantly copied and each call of King isInCheck() (required for possible move) requiring every possible move by the opponent to be generated. There likely is a way to subvert this by only only generating new moves for Pieces that had their moves affected by the previous move. This is non-trivial to implement and would require some work in several areas of the application. If somehow implemented however, it would likely be useable to only generate Moves for Pieces that were affected in Player.getLegalMoves() as well. All in all with realistic changes, without a complete rewrite of the code, move generation could probably be made to be faster by a factor of 100, with the mentioned changes and more efficient data structures. Of course, this number is just a guess really.

Of course the best Chess engines typically use a Bitboard to handle their internal states efficiently, and that would be preferable for this as well and provide an even greater improvement for processing speed. I deemed this to be unnecessary for the goals of the course, and require too much research to implement. If I ever build another engine, I will likely try to utilize this from the beginning, however.

### Performance Tests

|Scenario|Depth|Time Elapsed (ms)|
|--------|-----|-----------------|
|Opening Move (White)|1|6|
|Opening Move (White)|2|66|
|Opening Move (White)|3|583|
|Opening Move (White)|4|3953|
|Opening Move (White)|5|35959|
||||
|Opening Move (Black)|1|16|
|Opening Move (Black)|2|96|
|Opening Move (Black)|3|498|
|Opening Move (Black)|4|4866|
|Opening Move (Black)|5|31034|
||||
|Midgame|1|30|
|Midgame|2|136|
|Midgame|3|2509|
|Midgame|4|10800|
|Midgame|5|117652|


## Used Pre-existing Datastructures

Almost everything is implemented as a simple Array, but the following Java utilities are utilized by the project.

**Java.util.Random** MinmaxAB and Minmax both use Java's own random utilization to decide between moves deemed roughly equal by the engine.   
**Java.io.PrintWriter** and **Java.util.Scanner** PrintWriter is used by the XBoard class to write inputs to the application. Technically simple System.out calls might do the same but there might be fringe scenarios where this does not work. Java.util.Scanner is used by main.java to determine if XBoard is calling the application or if its a user wanting to use the text UI provided by the engine. Scanner is also used by Connection to read inputs from XBoard and Human.java to read inputs from the user.
